## Shortcuts
""" 
SHORTCUTS

long comment : Alt + Shift + A
"""
## Imports
# IMPORTS

import numpy as np
import matplotlib.pyplot as plt
from scipy import constants # for G, but after scaling, we did not need it
import matplotlib.animation as animation
import time

## Variables
""" 
In our first version, we had seperate arrays for the x and y coordinates/velocities/accelerations, and an order array for the for loops:

xpos = np.zeros(4, dtype = float) # x&y position coordinates [m]
ypos = np.zeros(4, dtype = float)
xvel = np.zeros(4, dtype = float) # x&y velocity components [m/s]
yvel = np.zeros(4, dtype = float)
xacc = np.zeros(4, dtype = float) # x&y acceleration components [m/s^2]
yacc = np.zeros(4, dtype = float)

dist = np.zeros(6, dtype = float) # distances of the 4 bodies (1<-2, 1<-3, 1<-4, 2<-3, 2<-4, 3<-4) [m]

xCOforce = np.zeros(6, dtype = float) # forces between the 4 bodies (1<-2, 1<-3, 1<-4, 2<-3, 2<-4, 3<-4) [N]
yCOforce = np.zeros(6, dtype = float)
xforce = np.zeros(4, dtype = float) # forces acting on the 4 bodies (1,2,3,4) [N]
yforce = np.zeros(4, dtype = float)

order = np.array([[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]]) # indexes in the order of usage of the 3 bodies (for "for" loop)
"""
# VARIABLES

# Number of bodies
b=4

# Timestep - Might change frequently
dt = 5e-2 

# Arrays
mass = np.zeros(b, dtype = float) # masses of the 4 bodies [kg]

pos = np.zeros((b, 2), dtype=float) # x&y position coordinates [m]
vel = np.zeros((b, 2), dtype=float) # x&y velocity components [m/s]
acc = np.zeros((b, 2), dtype=float) # x&y acceleration components [m/s^2]

# Constants
colours = ["red","blue","black","green"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps
opacity = np.linspace(0.1,1,int(N/n)+1)

G = 1 #constants.gravitational_constant # [m^3/(kg*s^2)]
PI = np.pi # precise pi value

print(type(mass),type(pos), type(vel), type(acc)) # for checking
## Functions
#FUNCTIONS

#Function to compute acceleration

def acceleration (pos, acc, mass):
    
    """
    Vectorized b-body acceleration.
    pos  : (b,2)
    mass : (b,)
    """
    r = pos[:, None, :] - pos[None, :, :]      # (b, 1, 2) - (1, b, 2) = (b, b, 2) we inserted a new axis in the middle. r[i, j] = pos[i] - pos[j]
    dist = np.linalg.norm(r, axis=2)           # (b,b), axis = 0 -> down the rows, axis = 1 -> across columns, axis = 2 -> depth (x/y components)
        # dist[i, j] = sqrt(r[i, j, 0]**2 + r[i, j, 1]**2)
    same = dist > 0                            # boolean
    inv_dist3 = np.zeros_like(dist)
    inv_dist3[same] = 1.0 / dist[same]**3

    acc = -G * np.sum(mass[None, :, None] * r * inv_dist3[:, :, None], axis=1) #(b, 2)
    return acc
Euler method
#Euler method

def Euler(pos, vel, acc):
    acc = acceleration(pos, acc, mass)

    # Velocity, position
    vel = vel + acc * dt
    pos = pos + vel * dt
    
    return pos, vel
Runge-Kutta method
# Runge-Kutta Method
# Converting the second-order ODE into two first-order ODEs
# Sources:
#   https://www.youtube.com/watch?v=m3W47PKXmYY
#   https://trinket.io/glowscript/038b9f8cfc

def RK4(pos, vel, dt):
    k1_v = acceleration(pos, acc, mass)
    k1_x = vel

    k2_v = acceleration(pos + 0.5*dt*k1_x, acc, mass)
    k2_x = vel + 0.5*dt*k1_v

    k3_v = acceleration(pos + 0.5*dt*k2_x, acc, mass)
    k3_x = vel + 0.5*dt*k2_v

    k4_v = acceleration(pos + dt*k3_x, acc, mass)
    k4_x = vel + dt*k3_v

    pos = pos + (dt/6)*(k1_x + 2*k2_x + 2*k3_x + k4_x)
    vel = vel + (dt/6)*(k1_v + 2*k2_v + 2*k3_v + k4_v)

    return pos, vel
Leapfrog method
#Leapfrog method

"""
For this method, we have the velocities at half-time steps, and the position and the acceleration at integer time steps.
"""
def Leapfrog(pos, vel, acc):
    vel_half = vel + 0.5 * acc * dt
    pos = pos + vel_half * dt
    acc = acceleration(pos, acc,  mass)
    vel = vel_half + 0.5 * acc * dt
    return pos, vel, acc
Step computation
def step_system(method):
    global pos, vel, acc
        # use global to avoid passing these parameters every time we call this function, so this does not create new local variables
        
    if (method=="Euler"):
        pos, vel=Euler(pos, vel, acc)

    elif(method=="RK4"):
        pos, vel = RK4(pos, vel, dt)
    
    elif(method=="Leapfrog"):
        pos, vel, acc = Leapfrog(pos, vel, acc)
    
    else:
        raise(ValueError('Invalid method. Please try "Euler" or "RK4"'))

Energy, angular momentum
#Total energy

def total_energy(pos, vel, mass, G):
    #kinetic
    KE = 0.5 * np.sum(mass * np.sum(vel**2, axis=1))

    #potential
    PE = 0.0
    for i in range(b):
        for j in range(i+1, b):
            r = np.linalg.norm(pos[i] - pos[j])
            PE -= G * mass[i] * mass[j] / r

    return KE + PE

#Angular momentum

def total_angular_momentum(pos, vel, mass):
    
    L=np.sum(mass * (pos[:,0]*vel[:,1] - pos[:,1]*vel[:,0]))  # L = m * (r x v)
    
    return L

Animation
""" 
This function can run the whole simulation before plotting, so computation is faster
 """

def simulate(method, pos, vel, acc, steps, save_every):
    pos_hist = np.zeros((steps//save_every, b, 2))
    """pos = pos0.copy()
    vel = vel0.copy()
    acc = acc0.copy()"""

    for k in range(steps):
        if (k%save_every==0):  # to make things faster, we only save every save_every'th step
            pos_hist[k//save_every] = pos

        if method == "Euler":
            pos, vel = Euler(pos, vel, acc)
        elif method == "RK4":
            pos, vel = RK4(pos, vel, dt)
        elif method == "Leapfrog":
            pos, vel, acc = Leapfrog(pos, vel, acc)
        else:
            raise ValueError("Invalid method")

    return pos_hist

# ANIMATION

# Frames for animation
# Source:
#   https://matplotlib.org/stable/users/explain/animations/animations.html

def make_update(scat, traj, lines, cm_point):
    def update(frame):  # frame provided by FuncAnimation
        if frame >= traj.shape[0]: #make sure to return something
            return []

        #print(frame) #to see if it really runs
        
        pos_c = traj[frame] #current position

        # Update scatter positions
        scat.set_offsets(pos_c)

        # Update trajectories for each body
        for i, line in enumerate(lines): # i is the idex, line is the actual line segment's position
            line.set_data(traj[:frame+1, i, 0], traj[:frame+1, i, 1])

        # Compute and update center of mass marker
        cm = np.sum(mass[:, None] * pos_c, axis=0) / np.sum(mass)
        cm_point.set_data([cm[0]], [cm[1]])


        # Return artists to update
        return [scat, cm_point] + lines
    return update  #when we call the animation function, it runs with a different frame value in every loop
## Initializations
#INITIALIZATIONS

# Sun Earth Mars comet
# All numbers are scaled down to align with G=1
b=4

mass = np.array([1, 3*1e-6, 3.2*1e-7, 1.1e-16] )
pos = np.array([[0.0, 0.0], [1, 0.0], [1.5, 0.0], [-0.586, 0.0]])
vel = np.array([[0, -(3*1e-6*1 + 3.2*1e-7*0.8165)], [0, 1], [0,  0.8165], [0.0, -1.83]])
acc = np.zeros((b,2), dtype=float)

dt = 5e-2

colours = ["red","blue","black","green"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

print(type(pos), type(vel), type(mass))
#Initialization 2
# (known stable initial position - 8)   https://trinket.io/glowscript/038b9f8cfc

"""
bodies on one line around origin, central symmetry
two outer bodies have same velocity, the one in the middle has twice that in the opposite direction
all bodies have the same mass
"""
b=3
mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

dt = 5e-2

colours = ["red","blue","black"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 2000
save_every=10

print(type(pos), type(vel), type(mass))
# 4-body 
## Computation with Euler
# COMPUTATION & PLOT

#Euler method on SEMC (Sun-Earth-Mars-comet)
b=4

mass = np.array([1, 3*1e-6, 3.2*1e-7, 1.1e-16] )
pos = np.array([[0.0, 0.0], [1, 0.0], [1.5, 0.0], [-0.586, 0.0]])
vel = np.array([[0, -(3*1e-6*1 + 3.2*1e-7*0.8165)], [0, 1], [0,  0.8165], [0.0, -1.83]])
acc = np.zeros((b,2), dtype=float)

dt = 5e-2

objects = ["Sun", "Earth", "Mars", "comet"]
colours = ["red","blue","black","green"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

# Plot Initialization
plt.figure(figsize=(10,5))
plt.xlim(-5, 40)
plt.ylim(-10, 15)
for i in range(b):
    plt.plot(pos[i, 0], pos[i, 1], marker = '*', color = colours[i], label=objects[i])

# COMPUTATION
for j in range(N):
    pos, vel = Euler(pos, vel, acc)
        
    # Positions
    for i in range(b):
        # PLOT
        if (j%(n)==0):
            plt.plot(pos[i, 0], pos[i, 1], marker = '.', color = colours[i], alpha = opacity[j//n])

plt.title(f"Euler method, {N} steps, plotting every {n}th step, dt = {dt}")
plt.xlabel("x [AU]")
plt.ylabel("y [AU]")
plt.legend()
plt.grid()
plt.show()
# COMPUTATION & PLOT

#Euler method on SEMC (Sun-Earth-Mars-comet)
b=4

mass = np.array([1, 3*1e-6, 3.2*1e-7, 1.1e-16] )
pos = np.array([[0.0, 0.0], [1, 0.0], [1.5, 0.0], [-0.586, 0.0]])
vel = np.array([[0, -(3*1e-6*1 + 3.2*1e-7*0.8165)], [0, 1], [0,  0.8165], [0.0, -1.83]])
acc = np.zeros((b,2), dtype=float)

dt = 5e-3

objects = ["Sun", "Earth", "Mars", "comet"]
colours = ["red","blue","black","green"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

# Plot Initialization
plt.figure(figsize=(10,5))
plt.xlim(-5, 40)
plt.ylim(-10, 15)
for i in range(b):
    plt.plot(pos[i, 0], pos[i, 1], marker = '*', color = colours[i], label=objects[i])

# COMPUTATION
for j in range(N):
    pos, vel = Euler(pos, vel, acc)
        
    # Positions
    for i in range(b):
        # PLOT
        if (j%(n)==0):
            plt.plot(pos[i, 0], pos[i, 1], marker = '.', color = colours[i], alpha = opacity[j//n])

plt.title(f"Euler method, {N} steps, plotting every {n}th step, dt = {dt}")
plt.xlabel("x [AU]")
plt.ylabel("y [AU]")
plt.legend()
plt.grid()
plt.show()
#Saving animation
#Euler method on SEMC (Sun-Earth-Mars-comet)
b=4

mass = np.array([1, 3*1e-6, 3.2*1e-7, 1.1e-16] )
pos = np.array([[0.0, 0.0], [1, 0.0], [1.5, 0.0], [-0.586, 0.0]])
vel = np.array([[0, -(3*1e-6*1 + 3.2*1e-7*0.8165)], [0, 1], [0,  0.8165], [0.0, -1.83]])
acc = np.zeros((b,2), dtype=float)

dt = 5e-2

objects = ["Sun", "Earth", "Mars", "comet"]
colours = ["red","blue","black","green"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

#Plot
fig, ax = plt.subplots(figsize=(10, 5))
ax.set_xlim(-5, 40)
ax.set_ylim(-10, 15)
ax.set_title(f"Euler method, {steps} steps, plotting every {save_every}th step, dt = {dt}")
ax.set_aspect("equal")
ax.set_xlabel("x [AU]")
ax.set_ylabel("y [AU]")

#Plot initialization
for i in range(b):
    ax.plot(pos[i, 0], pos[i, 1], marker = '*', color = colours[i], label=objects[i])

traj = simulate("Euler", pos, vel, acc, steps, save_every)
#print(traj.shape[0]) #checking shapes

# scatter for bodies
scat = ax.scatter(traj[0, :, 0], traj[0, :, 1], s=20, c=colours)

#print(colours) 
#print(len(colours), type(colours))

# line objects for trajectories
lines = []
for color in colours:
    line = ax.plot([], [], color=color, alpha=0.8, linewidth=0.3)[0]
    lines.append(line)

# center of mass marker
cm_point = ax.plot([], [], 'kx', markersize=1, label="center of mass")[0]
#ax.legend()  , label="Center of mass"

ax.legend()
ax.grid()
ani = animation.FuncAnimation(fig, make_update(scat, traj, lines, cm_point), frames=len(traj), interval=1, blit=True) #only preview

ani.save("E_24000-20_5e-2.gif", writer="pillow", fps=100, dpi=150) #animation in vs code does not work well so we saved it as a gif file

"""Energy diagram - not really interesting, there will be a comparison later

energy_hist_E= []
l_hist_E = []
time_hist_E =[]

for i in range(N):
    step_system("Euler")

    # update energy, angualar momentum, time
    energy_hist_E.append(total_energy(pos, vel, mass, G))
    l_hist_E.append(total_angular_momentum(pos, vel, mass))
    time_hist_E.append(i*dt)

figure, axes= plt.subplots(1, 2, figsize=(12, 5))

axes[0].plot(time_hist_E, energy_hist_E)
axes[0].set_title("Total Energy")
axes[0].set_xlabel("Time")
axes[0].set_ylabel("E")

axes[1].plot(time_hist_E, l_hist_E)
axes[1].set_title("Total Angular Momentum")
axes[1].set_xlabel("Time")
axes[1].set_ylabel("L")

plt.tight_layout()
plt.grid()
plt.show()

"""
## Computation with RK4
# COMPUTATION & PLOT

#RK4 method on SEMC (Sun-Earth-Mars-comet)
b=4

mass = np.array([1, 3*1e-6, 3.2*1e-7, 1.1e-16] )
pos = np.array([[0.0, 0.0], [1, 0.0], [1.5, 0.0], [-0.586, 0.0]])
vel = np.array([[0, -(3*1e-6*1 + 3.2*1e-7*0.8165)], [0, 1], [0,  0.8165], [0.0, -1.83]])
acc = np.zeros((b,2), dtype=float)

dt = 5e-2

objects = ["Sun", "Earth", "Mars", "comet"]
colours = ["red","blue","black","green"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

# Plot Initialization
plt.figure(figsize=(10,5))
plt.xlim(-5, 40)
plt.ylim(-10, 15)

#Initialization
for i in range(b):
    plt.plot(pos[i, 0], pos[i, 1], marker = '*', color = colours[i], label=objects[i])

# COMPUTATION
for j in range(N):
    pos, vel = RK4(pos, vel, dt)
        
    # Positions
    for i in range(b):
        # PLOT
        if (j%(n)==0):
            plt.plot(pos[i, 0], pos[i, 1], marker = '.', color = colours[i], alpha = opacity[j//n])

plt.title(f"Runge-Kutta method, {N} steps, plotting every {n}th step, dt = {dt}")
plt.xlabel("x [AU]")
plt.ylabel("y [AU]")
plt.legend()
plt.grid()
plt.show()
#Saving animation
#RK4 method on SEMC (Sun-Earth-Mars-comet)
b=4

mass = np.array([1, 3*1e-6, 3.2*1e-7, 1.1e-16] )
pos = np.array([[0.0, 0.0], [1, 0.0], [1.5, 0.0], [-0.586, 0.0]])
vel = np.array([[0, -(3*1e-6*1 + 3.2*1e-7*0.8165)], [0, 1], [0,  0.8165], [0.0, -1.83]])
acc = np.zeros((b,2), dtype=float)

dt = 5e-2

objects = ["Sun", "Earth", "Mars", "comet"]
colours = ["red","blue","black","green"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

#Plot
fig, ax = plt.subplots(figsize=(10, 5))
ax.set_xlim(-5, 40)
ax.set_ylim(-10, 15)
ax.set_title(f"Runge-Kutta method, {steps} steps, plotting every {save_every}th step, dt = {dt}")
ax.set_aspect("equal")
ax.set_xlabel("x [AU]")
ax.set_ylabel("y [AU]")

#Plot initialization
for i in range(b):
    ax.plot(pos[i, 0], pos[i, 1], marker = '*', color = colours[i], label=objects[i])

traj = simulate("RK4", pos, vel, acc, steps, save_every)
#print(traj.shape[0]) #checking shapes

# scatter for bodies
scat = ax.scatter(traj[0, :, 0], traj[0, :, 1], s=20, c=colours)

#print(colours) 
#print(len(colours), type(colours))

# line objects for trajectories
lines = []
for color in colours:
    line = ax.plot([], [], color=color, alpha=0.8, linewidth=0.3)[0]
    lines.append(line)

# center of mass marker
cm_point = ax.plot([], [], 'kx', markersize=1, label="center of mass")[0]
#ax.legend()  , label="Center of mass"

ax.legend()
ax.grid()
ani = animation.FuncAnimation(fig, make_update(scat, traj, lines, cm_point), frames=len(traj), interval=1, blit=True) #only preview

ani.save("RK4_24000-20_5e-2.gif", writer="pillow", fps=100, dpi=150) #animation in vs code does not work well so we saved it as a gif file

## Computation with Leapfrog
# COMPUTATION & PLOT

#Leapfrog method on SEMC (Sun-Earth-Mars-comet)
b=4

mass = np.array([1, 3*1e-6, 3.2*1e-7, 1.1e-16] )
pos = np.array([[0.0, 0.0], [1, 0.0], [1.5, 0.0], [-0.586, 0.0]])
vel = np.array([[0, -(3*1e-6*1 + 3.2*1e-7*0.8165)], [0, 1], [0,  0.8165], [0.0, -1.83]])
acc = np.zeros((b,2), dtype=float)

dt = 5e-2

objects = ["Sun", "Earth", "Mars", "comet"]
colours = ["red","blue","black","green"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

# Plot Initialization
plt.figure(figsize=(10,5))
plt.xlim(-5, 40)
plt.ylim(-10, 15)

#Initialization
for i in range(b):
    plt.plot(pos[i, 0], pos[i, 1], marker = '*', color = colours[i], label=objects[i])

# COMPUTATION
for j in range(N):
    pos, vel, acc = Leapfrog(pos, vel, acc)
        
    # Positions
    for i in range(b):
        # PLOT
        if (j%(n)==0):
            plt.plot(pos[i, 0], pos[i, 1], marker = '.', color = colours[i], alpha = opacity[j//n])

plt.title(f"Leapfrog method, {N} steps, plotting every {n}th step, dt = {dt}")
plt.xlabel("x [AU]")
plt.ylabel("y [AU]")
plt.legend()
plt.grid()
plt.show()
# COMPUTATION & PLOT

#Leapfrog method on SEMC (Sun-Earth-Mars-comet)
b=4

mass = np.array([1, 3*1e-6, 3.2*1e-7, 1.1e-16] )
pos = np.array([[0.0, 0.0], [1, 0.0], [1.5, 0.0], [-0.586, 0.0]])
vel = np.array([[0, -(3*1e-6*1 + 3.2*1e-7*0.8165)], [0, 1], [0,  0.8165], [0.0, -1.83]])
acc = np.zeros((b,2), dtype=float)

dt = 5e-3

objects = ["Sun", "Earth", "Mars", "comet"]
colours = ["red","blue","black","green"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

# Plot Initialization
plt.figure(figsize=(10,5))
plt.xlim(-5, 40)
plt.ylim(-10, 15)

#Initialization
for i in range(b):
    plt.plot(pos[i, 0], pos[i, 1], marker = '*', color = colours[i], label=objects[i])

# COMPUTATION
for j in range(N):
    pos, vel, acc = Leapfrog(pos, vel, acc)
        
    # Positions
    for i in range(b):
        # PLOT
        if (j%(n)==0):
            plt.plot(pos[i, 0], pos[i, 1], marker = '.', color = colours[i], alpha = opacity[j//n])

plt.title(f"Leapfrog method, {N} steps, plotting every {n}th step, dt = {dt}")
plt.xlabel("x [AU]")
plt.ylabel("y [AU]")
plt.legend()
plt.grid()
plt.show()
#Saving animation
#Leapfrog method on SEMC (Sun-Earth-Mars-comet)
b=4

mass = np.array([1, 3*1e-6, 3.2*1e-7, 1.1e-16] )
pos = np.array([[0.0, 0.0], [1, 0.0], [1.5, 0.0], [-0.586, 0.0]])
vel = np.array([[0, -(3*1e-6*1 + 3.2*1e-7*0.8165)], [0, 1], [0,  0.8165], [0.0, -1.83]])
acc = np.zeros((b,2), dtype=float)

dt = 5e-2

objects = ["Sun", "Earth", "Mars", "comet"]
colours = ["red","blue","black","green"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

#Plot
fig, ax = plt.subplots(figsize=(10, 5))
ax.set_xlim(-5, 40)
ax.set_ylim(-10, 15)
ax.set_title(f"Leapfrog method, {steps} steps, plotting every {save_every}th step, dt = {dt}")
ax.set_aspect("equal")
ax.set_xlabel("x [AU]")
ax.set_ylabel("y [AU]")

#Plot initialization
for i in range(b):
    ax.plot(pos[i, 0], pos[i, 1], marker = '*', color = colours[i], label=objects[i])

traj = simulate("Leapfrog", pos, vel, acc, steps, save_every)
#print(traj.shape[0]) #checking shapes

# scatter for bodies
scat = ax.scatter(traj[0, :, 0], traj[0, :, 1], s=20, c=colours)

#print(colours) 
#print(len(colours), type(colours))

# line objects for trajectories
lines = []
for color in colours:
    line = ax.plot([], [], color=color, alpha=0.8, linewidth=0.3)[0]
    lines.append(line)

# center of mass marker
cm_point = ax.plot([], [], 'kx', markersize=1, label="center of mass")[0]
#ax.legend()  , label="Center of mass"

ax.legend()
ax.grid()
ani = animation.FuncAnimation(fig, make_update(scat, traj, lines, cm_point), frames=len(traj), interval=1, blit=True) #only preview

ani.save("L_24000-20_5e-2.gif", writer="pillow", fps=100, dpi=150) #animation in vs code does not work well so we saved it as a gif file

## Comparison
#Error compariosn

# Initialization 
b=4

mass = np.array([1, 3*1e-6, 3.2*1e-7, 1.1e-16] )
pos = np.array([[0.0, 0.0], [1, 0.0], [1.5, 0.0], [-0.586, 0.0]])
vel = np.array([[0, -(3*1e-6*1 + 3.2*1e-7*0.8165)], [0, 1], [0,  0.8165], [0.0, -1.83]])
acc = np.zeros((b,2), dtype=float)

dt = 5e-2

objects = ["Sun", "Earth", "Mars", "comet"]
colours = ["red","blue","black","green"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

print(type(pos), type(vel), type(mass))

energy_hist_E= np.zeros(N, dtype=float)
l_hist_E = np.zeros(N, dtype=float)
time_hist_E = np.zeros(N, dtype=float)

for i in range(N):
    step_system("Euler")

    # update energy, angualar momentum, time
    energy_hist_E[i] = total_energy(pos, vel, mass, G)
    l_hist_E[i] = total_angular_momentum(pos, vel, mass)
    time_hist_E[i] = (i*dt)


# Initialize again

mass = np.array([1, 3*1e-6, 3.2*1e-7, 1.1e-16] )
pos = np.array([[0.0, 0.0], [1, 0.0], [1.5, 0.0], [-0.586, 0.0]])
vel = np.array([[0, -(3*1e-6*1 + 3.2*1e-7*0.8165)], [0, 1], [0,  0.8165], [0.0, -1.83]])
acc = np.zeros((b,2), dtype=float)

print(type(pos), type(vel), type(mass))

energy_hist_RK= np.zeros(N, dtype=float)
l_hist_RK = np.zeros(N, dtype=float)
time_hist_RK = np.zeros(N, dtype=float)

for i in range(N):
    step_system("RK4")

    # update energy, angualar momentum, time
    energy_hist_RK[i] = total_energy(pos, vel, mass, G)
    l_hist_RK[i] = total_angular_momentum(pos, vel, mass)
    time_hist_RK[i] = (i*dt)

# Initialize once again

mass = np.array([1, 3*1e-6, 3.2*1e-7, 1.1e-16] )
pos = np.array([[0.0, 0.0], [1, 0.0], [1.5, 0.0], [-0.586, 0.0]])
vel = np.array([[0, -(3*1e-6*1 + 3.2*1e-7*0.8165)], [0, 1], [0,  0.8165], [0.0, -1.83]])
acc = np.zeros((b,2), dtype=float)

print(type(pos), type(vel), type(mass))

energy_hist_L= np.zeros(N, dtype=float)
l_hist_L = np.zeros(N, dtype=float)
time_hist_L = np.zeros(N, dtype=float)

for i in range(N):
    step_system("Leapfrog")

    # update energy, angualar momentum, time
    energy_hist_L[i] = total_energy(pos, vel, mass, G)
    l_hist_L[i] = total_angular_momentum(pos, vel, mass)
    time_hist_L[i] = (i*dt)

figure, axes= plt.subplots(2, 2, figsize=(12,12))

axes[0,0].plot(time_hist_E, np.abs((energy_hist_E-energy_hist_E[0])/energy_hist_E[0]), label="Euler", color="red")
axes[0,0].plot(time_hist_RK, np.abs((energy_hist_RK-energy_hist_RK[0])/energy_hist_RK[0]), label="RK4", color="blue")
axes[0,0].plot(time_hist_L, np.abs((energy_hist_L-energy_hist_L[0])/energy_hist_L[0]), label="Leapfrog", color="green")
axes[0,0].set_title(f"Relative Energy Error, {N} steps, dt = {dt}")
axes[0,0].set_xlabel("Time")
axes[0,0].set_ylabel("|(E-E0)/E0|")
axes[0,0].set_xlim(4900, 5000)
axes[0,0].legend()
axes[0,0].grid()

axes[0,1].plot(time_hist_E, np.abs((energy_hist_E-energy_hist_E[0])/energy_hist_E[0]), label="Euler", color="red")
axes[0,1].plot(time_hist_RK, np.abs((energy_hist_RK-energy_hist_RK[0])/energy_hist_RK[0]), label="RK4", color="blue")
axes[0,1].plot(time_hist_L, np.abs((energy_hist_L-energy_hist_L[0])/energy_hist_L[0]), label="Leapfrog", color="green")
axes[0,1].set_title(f"Relative Energy Error, {N} steps, dt = {dt}")
axes[0,1].set_xlabel("Time")
axes[0,1].set_ylabel("log(|(E-E0)/E0|)")
axes[0,1].set_yscale('log')
axes[0,1].set_xlim(4900, 5000)
axes[0,1].legend()
axes[0,1].grid()

axes[1,0].plot(time_hist_E, np.abs((l_hist_E-l_hist_E[0])/l_hist_E[0]), label="Euler", color="red")
axes[1,0].plot(time_hist_RK, np.abs((l_hist_RK-l_hist_RK[0])/l_hist_RK[0]), label="RK4", color="blue")
axes[1,0].plot(time_hist_L, np.abs((l_hist_L-l_hist_L[0])/l_hist_L[0]), label="Leapfrog", color="green")
axes[1,0].set_title(f"Relative Angular Momentum Error, {N} steps, dt = {dt}")
axes[1,0].set_xlabel("Time")
axes[1,0].set_ylabel("|(L-L0)/L0|")
axes[1,0].legend()
axes[1,0].grid()

axes[1,1].plot(time_hist_E, np.abs((l_hist_E-l_hist_E[0])/l_hist_E[0]), label="Euler", color="red")
axes[1,1].plot(time_hist_RK, np.abs((l_hist_RK-l_hist_RK[0])/l_hist_RK[0]), label="RK4", color="blue")
axes[1,1].plot(time_hist_L, np.abs((l_hist_L-l_hist_L[0])/l_hist_L[0]), label="Leapfrog", color="green")
axes[1,1].set_title(f"Relative Angular Momentum Error, {N} steps, dt = {dt}")
axes[1,1].set_xlabel("Time")
axes[1,1].set_ylabel("log(|(L-L0)/L0|)")
axes[1,1].set_yscale('log')
axes[1,1].legend()
axes[1,1].grid()

plt.tight_layout()
plt.show()
#Error compariosn

# Initialization 
b=4

mass = np.array([1, 3*1e-6, 3.2*1e-7, 1.1e-16] )
pos = np.array([[0.0, 0.0], [1, 0.0], [1.5, 0.0], [-0.586, 0.0]])
vel = np.array([[0, -(3*1e-6*1 + 3.2*1e-7*0.8165)], [0, 1], [0,  0.8165], [0.0, -1.83]])
acc = np.zeros((b,2), dtype=float)

dt = 5e-4

objects = ["Sun", "Earth", "Mars", "comet"]
colours = ["red","blue","black","green"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

print(type(pos), type(vel), type(mass))

energy_hist_E= np.zeros(N, dtype=float)
l_hist_E = np.zeros(N, dtype=float)
time_hist_E = np.zeros(N, dtype=float)

for i in range(N):
    step_system("Euler")

    # update energy, angualar momentum, time
    energy_hist_E[i] = total_energy(pos, vel, mass, G)
    l_hist_E[i] = total_angular_momentum(pos, vel, mass)
    time_hist_E[i] = (i*dt)


# Initialize again

mass = np.array([1, 3*1e-6, 3.2*1e-7, 1.1e-16] )
pos = np.array([[0.0, 0.0], [1, 0.0], [1.5, 0.0], [-0.586, 0.0]])
vel = np.array([[0, -(3*1e-6*1 + 3.2*1e-7*0.8165)], [0, 1], [0,  0.8165], [0.0, -1.83]])
acc = np.zeros((b,2), dtype=float)

print(type(pos), type(vel), type(mass))

energy_hist_RK= np.zeros(N, dtype=float)
l_hist_RK = np.zeros(N, dtype=float)
time_hist_RK = np.zeros(N, dtype=float)

for i in range(N):
    step_system("RK4")

    # update energy, angualar momentum, time
    energy_hist_RK[i] = total_energy(pos, vel, mass, G)
    l_hist_RK[i] = total_angular_momentum(pos, vel, mass)
    time_hist_RK[i] = (i*dt)

# Initialize once again

mass = np.array([1, 3*1e-6, 3.2*1e-7, 1.1e-16] )
pos = np.array([[0.0, 0.0], [1, 0.0], [1.5, 0.0], [-0.586, 0.0]])
vel = np.array([[0, -(3*1e-6*1 + 3.2*1e-7*0.8165)], [0, 1], [0,  0.8165], [0.0, -1.83]])
acc = np.zeros((b,2), dtype=float)

print(type(pos), type(vel), type(mass))

energy_hist_L= np.zeros(N, dtype=float)
l_hist_L = np.zeros(N, dtype=float)
time_hist_L = np.zeros(N, dtype=float)

for i in range(N):
    step_system("Leapfrog")

    # update energy, angualar momentum, time
    energy_hist_L[i] = total_energy(pos, vel, mass, G)
    l_hist_L[i] = total_angular_momentum(pos, vel, mass)
    time_hist_L[i] = (i*dt)

figure, axes= plt.subplots(2, 2, figsize=(12,12))

axes[0,0].plot(time_hist_E, np.abs((energy_hist_E-energy_hist_E[0])/energy_hist_E[0]), label="Euler", color="red")
axes[0,0].plot(time_hist_RK, np.abs((energy_hist_RK-energy_hist_RK[0])/energy_hist_RK[0]), label="RK4", color="blue")
axes[0,0].plot(time_hist_L, np.abs((energy_hist_L-energy_hist_L[0])/energy_hist_L[0]), label="Leapfrog", color="green")
axes[0,0].set_title(f"Relative Energy Error, {N} steps, dt = {dt}")
axes[0,0].set_xlabel("Time")
axes[0,0].set_ylabel("|(E-E0)/E0|")
axes[0,0].legend()
axes[0,0].grid()

axes[0,1].plot(time_hist_E, np.abs((energy_hist_E-energy_hist_E[0])/energy_hist_E[0]), label="Euler", color="red")
axes[0,1].plot(time_hist_RK, np.abs((energy_hist_RK-energy_hist_RK[0])/energy_hist_RK[0]), label="RK4", color="blue")
axes[0,1].plot(time_hist_L, np.abs((energy_hist_L-energy_hist_L[0])/energy_hist_L[0]), label="Leapfrog", color="green")
axes[0,1].set_title(f"Relative Energy Error, {N} steps, dt = {dt}")
axes[0,1].set_xlabel("Time")
axes[0,1].set_ylabel("log(|(E-E0)/E0|)")
axes[0,1].set_yscale('log')
axes[0,1].legend()
axes[0,1].grid()

axes[1,0].plot(time_hist_E, np.abs((l_hist_E-l_hist_E[0])/l_hist_E[0]), label="Euler", color="red")
axes[1,0].plot(time_hist_RK, np.abs((l_hist_RK-l_hist_RK[0])/l_hist_RK[0]), label="RK4", color="blue")
axes[1,0].plot(time_hist_L, np.abs((l_hist_L-l_hist_L[0])/l_hist_L[0]), label="Leapfrog", color="green")
axes[1,0].set_title(f"Relative Angular Momentum Error, {N} steps, dt = {dt}")
axes[1,0].set_xlabel("Time")
axes[1,0].set_ylabel("|(L-L0)/L0|")
axes[1,0].legend()
axes[1,0].grid()

axes[1,1].plot(time_hist_E, np.abs((l_hist_E-l_hist_E[0])/l_hist_E[0]), label="Euler", color="red")
axes[1,1].plot(time_hist_RK, np.abs((l_hist_RK-l_hist_RK[0])/l_hist_RK[0]), label="RK4", color="blue")
axes[1,1].plot(time_hist_L, np.abs((l_hist_L-l_hist_L[0])/l_hist_L[0]), label="Leapfrog", color="green")
axes[1,1].set_title(f"Relative Angular Momentum Error, {N} steps, dt = {dt}")
axes[1,1].set_xlabel("Time")
axes[1,1].set_ylabel("log(|(L-L0)/L0|)")
axes[1,1].set_yscale('log')
axes[1,1].legend()
axes[1,1].grid()

plt.tight_layout()
plt.show()
# 3-body
## Initialization
#INITIALIZATIONS
# (known stable initial position - 8)   https://trinket.io/glowscript/038b9f8cfc

b=3

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

dt = 5e-2

colours = ["red","blue","black"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

print(type(pos), type(vel), type(mass))
## Euler method
# COMPUTATION & PLOT

#Initialization
b=3

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

dt = 5e-2

colours = ["red","blue","black"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

# Plot Initialization
plt.figure(figsize=(5,5))
plt.xlim(-1.5, 1.5)
plt.ylim(-1.5, 1.5)
for i in range(b):
    plt.plot(pos[i, 0], pos[i, 1], marker = 'o', color = "red", label="original position")

for j in range(N):
    # COMPUTATION
    pos, vel = Euler(pos, vel, acc)
        
    # Positions
    for i in range(b):
        # PLOT
        if (j%(n)==0):
            plt.plot(pos[i, 0], pos[i, 1], marker=".", color = "red", alpha=1/(i+1))

#change one position slightly
mass = np.array([1,1,1])
pos = np.array([[0.97000436+0.001, -0.24308753], [-0.97000436, 0.24308753], [0, 0]]) 
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

plt.plot(pos[0, 0], pos[0, 1], marker = 'o', color = "blue", label="changed initial position")
for i in range(1,b):
    plt.plot(pos[i, 0], pos[i, 1], marker = 'o', color = "blue")

for j in range(N):
    # COMPUTATION
    pos, vel = Euler(pos, vel, acc)
        
    # Positions
    for i in range(b):
        # PLOT
        if (j%(n)==0):
            plt.plot(pos[i, 0], pos[i, 1], marker="*", color = "blue", alpha=1/(i+1))
plt.legend()
plt.grid()
plt.show()

#alpha = opacity[j//n]
#Saving animation
#Animation on Euler init. !

b=3

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

dt = 5e-2

colours = ["red","blue","black"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=2

print(type(pos), type(vel), type(mass))

fig, ax = plt.subplots(figsize=(5, 5))
plt.xlim(-1.5, 1.5)
plt.ylim(-1.5, 1.5)
ax.set_aspect("equal")
ax.set_xlabel("x [AU]")
ax.set_ylabel("y [AU]")
ax.grid()

traj = simulate("Euler", pos, vel, acc, steps, save_every)
traj_end=traj[6500:7300]
#print(traj.shape[0]) #checking shapes

# scatter for bodies
scat = ax.scatter(traj_end[0, :, 0], traj_end[0, :, 1], s=20, c=colours)

#print(colours) 
#print(len(colours), type(colours))

# line objects for trajectories
lines = []
for color in colours:
    line = ax.plot([], [], color=color, alpha=0.8, linewidth=0.3)[0]
    lines.append(line)

# center of mass marker
cm_point = ax.plot([], [], 'kx', markersize=1)[0]
#ax.legend()  , label="Center of mass"

ani = animation.FuncAnimation(fig, make_update(scat, traj_end, lines, cm_point), frames=len(traj_end), interval=1, blit=True) #only preview

ani.save("Euler_3body_init_end_short.gif", writer="pillow", fps=100, dpi=150) #animation in vs code does not work well so we saved it as a gif file

#Saving animation
#Animation on Euler init. !

b=3

mass = np.array([1,1,1])
pos = np.array([[0.97000436+0.001, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

dt = 5e-2

colours = ["red","blue","black"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 31000
save_every=2

print(type(pos), type(vel), type(mass))

fig, ax = plt.subplots(figsize=(5, 5))
plt.xlim(-1.5, 1.5)
plt.ylim(-1.5, 1.5)
ax.set_aspect("equal")
ax.set_xlabel("x [AU]")
ax.set_ylabel("y [AU]")
ax.grid()

traj_full = simulate("Euler", pos, vel, acc, steps, save_every)
traj=traj_full[14800:15100]
#print(traj.shape[0]) #checking shapes

# scatter for bodies
scat = ax.scatter(traj[0, :, 0], traj[0, :, 1], s=20, c=colours)

#print(colours) 
#print(len(colours), type(colours))

# line objects for trajectories
lines = []
for color in colours:
    line = ax.plot([], [], color=color, alpha=0.8, linewidth=0.3)[0]
    lines.append(line)

# center of mass marker
cm_point = ax.plot([], [], 'kx', markersize=1)[0]
#ax.legend()  , label="Center of mass"

ani = animation.FuncAnimation(fig, make_update(scat, traj, lines, cm_point), frames=len(traj), interval=1, blit=True) #only preview

ani.save("Euler_3body_changed.gif", writer="pillow", fps=100, dpi=150) #animation in vs code does not work well so we saved it as a gif file

## Runge-Kutta
# COMPUTATION & PLOT

b=3

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

dt = 5e-2

colours = ["red","blue","black"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

print(type(pos), type(vel), type(mass))

# Plot Initialization
plt.figure(figsize=(5,5))
plt.xlim(-1.5, 1.5)
plt.ylim(-1.5, 1.5)
for i in range(b):
    plt.plot(pos[i, 0], pos[i, 1], marker = 'o', color = "red")

for j in range(N):
    # COMPUTATION
    pos, vel = RK4(pos, vel, dt)
        
    # Positions
    for i in range(b):
        # PLOT
        if (j%(n)==0):
            plt.plot(pos[i, 0], pos[i, 1], marker=".", color = "red", alpha=1/(i+1))

mass = np.array([1,1,1])
pos = np.array([[0.97000436+0.001, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

plt.plot(pos[0, 0], pos[0, 1], marker = 'o', color = "blue", label="changed initial position")
for i in range(1,b):
    plt.plot(pos[i, 0], pos[i, 1], marker = 'o', color = "blue")

for j in range(N):
    # COMPUTATION
    pos, vel = RK4(pos, vel, dt)
        
    # Positions
    for i in range(b):
        # PLOT
        if (j%(n)==0):
            plt.plot(pos[i, 0], pos[i, 1], marker="*", color = "blue", alpha=1/(i+1))
plt.legend()
plt.grid()
plt.show()

#alpha = opacity[j//n]
#Saving animation
#Animation on RK4 init. 2

b=3

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

dt = 5e-2

colours = ["red","blue","black"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 50000
save_every=2

print(type(pos), type(vel), type(mass))

fig, ax = plt.subplots(figsize=(5, 5))
plt.xlim(-1.5, 1.5)
plt.ylim(-1.5, 1.5)
ax.set_aspect("equal")
ax.set_xlabel("x [AU]")
ax.set_ylabel("y [AU]")
ax.grid()

traj_full = simulate("RK4", pos, vel, acc, steps, save_every)
traj=traj_full[24800:24900]
#print(traj.shape[0]) #checking shapes

# scatter for bodies
scat = ax.scatter(traj[0, :, 0], traj[0, :, 1], s=20, c=colours)

#print(colours) 
#print(len(colours), type(colours))

# line objects for trajectories
lines = []
for color in colours:
    line = ax.plot([], [], color=color, alpha=0.8, linewidth=0.3)[0]
    lines.append(line)

# center of mass marker
cm_point = ax.plot([], [], 'kx', markersize=1)[0]
#ax.legend()  , label="Center of mass"

ani = animation.FuncAnimation(fig, make_update(scat, traj, lines, cm_point), frames=len(traj), interval=1, blit=True) #only preview

ani.save("RK4_3body_init.gif", writer="pillow", fps=100, dpi=150) #animation in vs code does not work well so we saved it as a gif file

#Saving animation
#Animation on RK4 init. 2

b=3

mass = np.array([1,1,1])
pos = np.array([[0.97000436+0.001, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

dt = 5e-2

colours = ["red","blue","black"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=2

print(type(pos), type(vel), type(mass))

fig, ax = plt.subplots(figsize=(5, 5))
plt.xlim(-1.5, 1.5)
plt.ylim(-1.5, 1.5)
ax.set_aspect("equal")
ax.set_xlabel("x [AU]")
ax.set_ylabel("y [AU]")
ax.grid()

traj_full = simulate("RK4", pos, vel, acc, steps, save_every)
traj=traj_full[10000:11900]
#print(traj.shape[0]) #checking shapes

# scatter for bodies
scat = ax.scatter(traj[0, :, 0], traj[0, :, 1], s=20, c=colours)

#print(colours) 
#print(len(colours), type(colours))

# line objects for trajectories
lines = []
for color in colours:
    line = ax.plot([], [], color=color, alpha=0.8, linewidth=0.3)[0]
    lines.append(line)

# center of mass marker
cm_point = ax.plot([], [], 'kx', markersize=1)[0]
#ax.legend()  , label="Center of mass"

ani = animation.FuncAnimation(fig, make_update(scat, traj, lines, cm_point), frames=len(traj), interval=1, blit=True) #only preview

ani.save("RK4_3body_changed.gif", writer="pillow", fps=100, dpi=150) #animation in vs code does not work well so we saved it as a gif file

## Leapfrog
# COMPUTATION & PLOT

b=3

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

dt = 5e-2

colours = ["red","blue","black"] # colours of the celestial objects on the plots
N = 10000 # number of steps
n = 50 # number of plotted steps

steps = 3000
save_every=2

print(type(pos), type(vel), type(mass))

# Plot Initialization
plt.figure(figsize=(5,5))
plt.xlim(-1.5, 1.5)
plt.ylim(-1.5, 1.5)
for i in range(b):
    plt.plot(pos[i, 0], pos[i, 1], marker = 'o', color = "red")

for j in range(N):
    # COMPUTATION
    pos, vel, acc = Leapfrog(pos, vel, acc)
        
    # Positions
    for i in range(b):
        # PLOT
        if (j%(n)==0):
            plt.plot(pos[i, 0], pos[i, 1], marker=".", color = "red", alpha=1/(i+1))

mass = np.array([1,1,1])
pos = np.array([[0.97000436+0.001, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

plt.plot(pos[0, 0], pos[0, 1], marker = 'o', color = "blue", label="changed initial position")
for i in range(1,b):
    plt.plot(pos[i, 0], pos[i, 1], marker = 'o', color = "blue")

for j in range(N):
    # COMPUTATION
    pos, vel, acc = Leapfrog(pos, vel, acc)
        
    # Positions
    for i in range(b):
        # PLOT
        if (j%(n)==0):
            plt.plot(pos[i, 0], pos[i, 1], marker="*", color = "blue", alpha=1/(i+1))
plt.legend()
plt.grid()
plt.show()

#alpha = opacity[j//n]
#Saving animation
#Animation on Leapfrog init. 2

b=3

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

dt = 5e-2

colours = ["red","blue","black"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 3000
save_every=2

print(type(pos), type(vel), type(mass))

fig, ax = plt.subplots(figsize=(5, 5))
plt.xlim(-1.5, 1.5)
plt.ylim(-1.5, 1.5)
ax.set_aspect("equal")
ax.set_xlabel("x [AU]")
ax.set_ylabel("y [AU]")
ax.grid()

traj_full = simulate("Leapfrog", pos, vel, acc, steps, save_every)
traj=traj_full[900:1500]
#print(traj.shape[0]) #checking shapes

# scatter for bodies
scat = ax.scatter(traj[0, :, 0], traj[0, :, 1], s=20, c=colours)

#print(colours) 
#print(len(colours), type(colours))

# line objects for trajectories
lines = []
for color in colours:
    line = ax.plot([], [], color=color, alpha=0.8, linewidth=0.3)[0]
    lines.append(line)

# center of mass marker
cm_point = ax.plot([], [], 'kx', markersize=1)[0]
#ax.legend()  , label="Center of mass"

ani = animation.FuncAnimation(fig, make_update(scat, traj, lines, cm_point), frames=len(traj), interval=1, blit=True) #only preview

ani.save("Leapfrog_3body_init.gif", writer="pillow", fps=100, dpi=150) #animation in vs code does not work well so we saved it as a gif file

## Comparison
#Energy diagram comparison

# Initialization 
b=3

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

dt = 5e-2

colours = ["red","blue","black"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

print(type(pos), type(vel), type(mass))

energy_hist_E= np.zeros(N, dtype=float)
l_hist_E = np.zeros(N, dtype=float)
time_hist_E = np.zeros(N, dtype=float)

for i in range(N):
    step_system("Euler")

    # update energy, angualar momentum, time
    energy_hist_E[i] = total_energy(pos, vel, mass, G)
    l_hist_E[i] = total_angular_momentum(pos, vel, mass)
    time_hist_E[i] = (i*dt)


# Initialize again

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

print(type(pos), type(vel), type(mass))

energy_hist_RK= np.zeros(N, dtype=float)
l_hist_RK = np.zeros(N, dtype=float)
time_hist_RK = np.zeros(N, dtype=float)

for i in range(N):
    step_system("RK4")

    # update energy, angualar momentum, time
    energy_hist_RK[i] = total_energy(pos, vel, mass, G)
    l_hist_RK[i] = total_angular_momentum(pos, vel, mass)
    time_hist_RK[i] = (i*dt)

# Initialize once again

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

print(type(pos), type(vel), type(mass))

energy_hist_L= np.zeros(N, dtype=float)
l_hist_L = np.zeros(N, dtype=float)
time_hist_L = np.zeros(N, dtype=float)

for i in range(N):
    step_system("Leapfrog")

    # update energy, angualar momentum, time
    energy_hist_L[i] = total_energy(pos, vel, mass, G)
    l_hist_L[i] = total_angular_momentum(pos, vel, mass)
    time_hist_L[i] = (i*dt)

figure, axes= plt.subplots(2, 3, figsize=(12, 12))

axes[0, 0].plot(time_hist_RK, energy_hist_RK-energy_hist_RK[0], label="RK4", color="blue")
axes[0,0].plot(time_hist_E, energy_hist_E-energy_hist_E[0], label="Euler", color="red")
axes[0,0].plot(time_hist_L, energy_hist_L-energy_hist_L[0], label="Leapfrog", color="green")
axes[0,0].set_title("Change in Total Energy")
axes[0,0].set_xlabel("Time")
axes[0,0].set_ylabel("E")
axes[0,0].legend()
axes[0,0].grid()

axes[0, 1].plot(time_hist_RK, energy_hist_RK-energy_hist_RK[0], label="RK4", color="blue")
axes[0, 1].plot(time_hist_E, energy_hist_E-energy_hist_E[0], label="Euler", color="red")
axes[0,1].set_title("Change in Total Energy")
axes[0,1].set_xlabel("Time")
axes[0,1].set_ylabel("E")
axes[0,1].legend()
axes[0,1].grid()

axes[0,2].plot(time_hist_RK, energy_hist_RK-energy_hist_RK[0], label="RK4", color="blue")
axes[0,2].set_title("Change in Total Energy")
axes[0,2].set_xlabel("Time")
axes[0,2].set_ylabel("E")
axes[0,2].legend()
axes[0,2].grid()

axes[1,0].plot(time_hist_RK, l_hist_RK-l_hist_RK[0], label="RK4", color="blue")
axes[1,0].plot(time_hist_E, l_hist_E-l_hist_E[0], label="Euler", color="red")
axes[1,0].plot(time_hist_L, l_hist_L-l_hist_L[0], label="Leapfrog", color="green")
axes[1,0].set_title("Change in Total Angular Momentum")
axes[1,0].set_xlabel("Time")
axes[1,0].set_ylabel("L")
axes[1,0].set_xlim(4900, 5000)
axes[1,0].legend()
axes[1,0].grid()

axes[1,1].plot(time_hist_E, l_hist_E-l_hist_E[0], label="Euler", color="red")
axes[1,1].plot(time_hist_L, l_hist_L-l_hist_L[0], label="Leapfrog", color="green")
axes[1,1].set_title("Change in Total Angular Momentum")
axes[1,1].set_xlabel("Time")
axes[1,1].set_ylabel("L")
axes[1,1].legend()
axes[1,1].grid()

axes[1,2].plot(time_hist_E, l_hist_E-l_hist_E[0], label="Euler", color="red")
axes[1,2].set_title("Change in Total Angular Momentum")
axes[1,2].set_xlabel("Time")
axes[1,2].set_ylabel("L")
axes[1,2].legend()
axes[1,2].grid()

plt.tight_layout()
plt.show()



#Error compariosn

# Initialization 
b=3

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

dt = 5e-2

colours = ["red","blue","black"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

print(type(pos), type(vel), type(mass))

energy_hist_E= np.zeros(N, dtype=float)
l_hist_E = np.zeros(N, dtype=float)
time_hist_E = np.zeros(N, dtype=float)

for i in range(N):
    step_system("Euler")

    # update energy, angualar momentum, time
    energy_hist_E[i] = total_energy(pos, vel, mass, G)
    l_hist_E[i] = total_angular_momentum(pos, vel, mass)
    time_hist_E[i] = (i*dt)


# Initialize again

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

print(type(pos), type(vel), type(mass))

energy_hist_RK= np.zeros(N, dtype=float)
l_hist_RK = np.zeros(N, dtype=float)
time_hist_RK = np.zeros(N, dtype=float)

for i in range(N):
    step_system("RK4")

    # update energy, angualar momentum, time
    energy_hist_RK[i] = total_energy(pos, vel, mass, G)
    l_hist_RK[i] = total_angular_momentum(pos, vel, mass)
    time_hist_RK[i] = (i*dt)

# Initialize once again

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

print(type(pos), type(vel), type(mass))

energy_hist_L= np.zeros(N, dtype=float)
l_hist_L = np.zeros(N, dtype=float)
time_hist_L = np.zeros(N, dtype=float)

for i in range(N):
    step_system("Leapfrog")

    # update energy, angualar momentum, time
    energy_hist_L[i] = total_energy(pos, vel, mass, G)
    l_hist_L[i] = total_angular_momentum(pos, vel, mass)
    time_hist_L[i] = (i*dt)

figure, axes= plt.subplots(2, 2, figsize=(12,12))

axes[0,0].plot(time_hist_E, np.abs((energy_hist_E-energy_hist_E[0])/energy_hist_E[0]), label="Euler", color="red")
axes[0,0].plot(time_hist_RK, np.abs((energy_hist_RK-energy_hist_RK[0])/energy_hist_RK[0]), label="RK4", color="blue")
axes[0,0].plot(time_hist_L, np.abs((energy_hist_L-energy_hist_L[0])/energy_hist_L[0]), label="Leapfrog", color="green")
axes[0,0].set_title(f"Relative Energy Error, {N} steps, dt = {dt}")
axes[0,0].set_xlabel("Time")
axes[0,0].set_ylabel("|(E-E0)/E0|")
axes[0,0].legend()
axes[0,0].grid()

axes[0,1].plot(time_hist_E, np.abs((energy_hist_E-energy_hist_E[0])/energy_hist_E[0]), label="Euler", color="red")
axes[0,1].plot(time_hist_RK, np.abs((energy_hist_RK-energy_hist_RK[0])/energy_hist_RK[0]), label="RK4", color="blue")
axes[0,1].plot(time_hist_L, np.abs((energy_hist_L-energy_hist_L[0])/energy_hist_L[0]), label="Leapfrog", color="green")
axes[0,1].set_title(f"Relative Energy Error, {N} steps, dt = {dt}")
axes[0,1].set_xlabel("Time")
axes[0,1].set_ylabel("log(|(E-E0)/E0|)")
axes[0,1].set_yscale('log')
axes[0,1].legend()
axes[0,1].grid()

axes[1,0].plot(time_hist_E, np.abs((l_hist_E-l_hist_E[0])/l_hist_E[0]), label="Euler", color="red")
axes[1,0].plot(time_hist_RK, np.abs((l_hist_RK-l_hist_RK[0])/l_hist_RK[0]), label="RK4", color="blue")
axes[1,0].plot(time_hist_L, np.abs((l_hist_L-l_hist_L[0])/l_hist_L[0]), label="Leapfrog", color="green")
axes[1,0].set_title(f"Relative Angular Momentum Error, {N} steps, dt = {dt}")
axes[1,0].set_xlabel("Time")
axes[1,0].set_ylabel("|(L-L0)/L0|")
axes[1,0].legend()
axes[1,0].grid()

axes[1,1].plot(time_hist_E, np.abs((l_hist_E-l_hist_E[0])/l_hist_E[0]), label="Euler", color="red")
axes[1,1].plot(time_hist_RK, np.abs((l_hist_RK-l_hist_RK[0])/l_hist_RK[0]), label="RK4", color="blue")
axes[1,1].plot(time_hist_L, np.abs((l_hist_L-l_hist_L[0])/l_hist_L[0]), label="Leapfrog", color="green")
axes[1,1].set_title(f"Relative Angular Momentum Error, {N} steps, dt = {dt}")
axes[1,1].set_xlabel("Time")
axes[1,1].set_ylabel("log(|(L-L0)/L0|)")
axes[1,1].set_yscale('log')
axes[1,1].legend()
axes[1,1].grid()

plt.tight_layout()
plt.show()
#Error compariosn

# Initialization 
b=3

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

dt = 5e-4

colours = ["red","blue","black"] # colours of the celestial objects on the plots
N = 100000 # number of steps
n = 500 # number of plotted steps

steps = 24000
save_every=20

print(type(pos), type(vel), type(mass))

energy_hist_E= np.zeros(N, dtype=float)
l_hist_E = np.zeros(N, dtype=float)
time_hist_E = np.zeros(N, dtype=float)

for i in range(N):
    step_system("Euler")

    # update energy, angualar momentum, time
    energy_hist_E[i] = total_energy(pos, vel, mass, G)
    l_hist_E[i] = total_angular_momentum(pos, vel, mass)
    time_hist_E[i] = (i*dt)


# Initialize again

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

print(type(pos), type(vel), type(mass))

energy_hist_RK= np.zeros(N, dtype=float)
l_hist_RK = np.zeros(N, dtype=float)
time_hist_RK = np.zeros(N, dtype=float)

for i in range(N):
    step_system("RK4")

    # update energy, angualar momentum, time
    energy_hist_RK[i] = total_energy(pos, vel, mass, G)
    l_hist_RK[i] = total_angular_momentum(pos, vel, mass)
    time_hist_RK[i] = (i*dt)

# Initialize once again

mass = np.array([1,1,1])
pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
acc = np.zeros((b, 2), dtype=float)

print(type(pos), type(vel), type(mass))

energy_hist_L= np.zeros(N, dtype=float)
l_hist_L = np.zeros(N, dtype=float)
time_hist_L = np.zeros(N, dtype=float)

for i in range(N):
    step_system("Leapfrog")

    # update energy, angualar momentum, time
    energy_hist_L[i] = total_energy(pos, vel, mass, G)
    l_hist_L[i] = total_angular_momentum(pos, vel, mass)
    time_hist_L[i] = (i*dt)

figure, axes= plt.subplots(2, 2, figsize=(12,12))

axes[0,0].plot(time_hist_E, np.abs((energy_hist_E-energy_hist_E[0])/energy_hist_E[0]), label="Euler", color="red")
axes[0,0].plot(time_hist_RK, np.abs((energy_hist_RK-energy_hist_RK[0])/energy_hist_RK[0]), label="RK4", color="blue")
axes[0,0].plot(time_hist_L, np.abs((energy_hist_L-energy_hist_L[0])/energy_hist_L[0]), label="Leapfrog", color="green")
axes[0,0].set_title(f"Relative Energy Error, {N} steps, dt = {dt}")
axes[0,0].set_xlabel("Time")
axes[0,0].set_ylabel("|(E-E0)/E0|")
axes[0,0].legend()
axes[0,0].grid()

axes[0,1].plot(time_hist_E, np.abs((energy_hist_E-energy_hist_E[0])/energy_hist_E[0]), label="Euler", color="red")
axes[0,1].plot(time_hist_RK, np.abs((energy_hist_RK-energy_hist_RK[0])/energy_hist_RK[0]), label="RK4", color="blue")
axes[0,1].plot(time_hist_L, np.abs((energy_hist_L-energy_hist_L[0])/energy_hist_L[0]), label="Leapfrog", color="green")
axes[0,1].set_title(f"Relative Energy Error, {N} steps, dt = {dt}")
axes[0,1].set_xlabel("Time")
axes[0,1].set_ylabel("log(|(E-E0)/E0|)")
axes[0,1].set_yscale('log')
axes[0,1].legend()
axes[0,1].grid()

axes[1,0].plot(time_hist_E, np.abs(l_hist_E-l_hist_E[0]), label="Euler", color="red")
axes[1,0].plot(time_hist_RK, np.abs(l_hist_RK-l_hist_RK[0]), label="RK4", color="blue")
axes[1,0].plot(time_hist_L, np.abs(l_hist_L-l_hist_L[0]), label="Leapfrog", color="green")
axes[1,0].set_title(f"Absolute Angular Momentum Error, {N} steps, dt = {dt}") #theoretically, L0 should be 0
axes[1,0].set_xlabel("Time")
axes[1,0].set_ylabel("|(L-L0)/L0|")
axes[1,0].legend()
axes[1,0].grid()

axes[1,1].plot(time_hist_E, np.abs(l_hist_E-l_hist_E[0]), label="Euler", color="red")
axes[1,1].plot(time_hist_RK, np.abs(l_hist_RK-l_hist_RK[0]), label="RK4", color="blue")
axes[1,1].plot(time_hist_L, np.abs(l_hist_L-l_hist_L[0]), label="Leapfrog", color="green")
axes[1,1].set_title(f"Absolute Angular Momentum Error, {N} steps, dt = {dt}")
axes[1,1].set_xlabel("Time")
axes[1,1].set_ylabel("log(|(L-L0)/L0|)")
axes[1,1].set_yscale('log')
axes[1,1].legend()
axes[1,1].grid()

plt.tight_layout()
plt.show()
b=3
dt = 5e-2

methods = ["Euler", "RK4", "Leapfrog"]
Ns = np.linspace(1000, 111000, 12, dtype=int)
execution_times = []

for m in methods:
    for s in Ns:
        mass = np.array([1,1,1])
        pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
        vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
        acc = np.zeros((b, 2), dtype=float)
        start_time = time.time()
        for i in range(s):
            step_system(m)
        execution_times.append(time.time() - start_time)

execution_times_E = execution_times[:len(Ns)]
execution_times_RK4 = execution_times[len(Ns):2*len(Ns)]
execution_times_L = execution_times[2*len(Ns):]

dt= 5e-4
execution_times = []

for m in methods:
    for s in Ns:
        mass = np.array([1,1,1])
        pos = np.array([[0.97000436, -0.24308753], [-0.97000436, 0.24308753], [0, 0]])
        vel = np.array([[0.93240737/2, 0.8643146/2], [0.93240737/2, 0.8643146/2], [-0.93240737, -0.8643146]]) 
        acc = np.zeros((b, 2), dtype=float)
        start_time = time.time()
        for i in range(s):
            step_system(m)
        execution_times.append(time.time() - start_time)

execution_times2_E = execution_times[:len(Ns)]
execution_times2_RK4 = execution_times[len(Ns):2*len(Ns)]
execution_times2_L = execution_times[2*len(Ns):]

dt1= 5e-2
dt2= 5e-4

fig, ax = plt.subplots(1, 2, figsize=(12,5))
ax[0].plot(Ns, execution_times_E, ".", color="red", label="Euler")
ax[0].plot(Ns, execution_times_RK4, ".", color="blue", label="RK4")
ax[0].plot(Ns, execution_times_L, ".", color="green", label="Leapfrog")
ax[0].set_title(f"Computation time with dt = {dt1}")
ax[0].set_xlabel("Number of steps")
ax[0].set_ylabel("Time [s]")
ax[0].legend()
ax[0].grid()

ax[1].plot(Ns, execution_times2_E, ".", color="red", label="Euler")
ax[1].plot(Ns, execution_times2_RK4, ".", color="blue", label="RK4")
ax[1].plot(Ns, execution_times2_L, ".", color="green", label="Leapfrog")
ax[1].set_title(f"Computation time with dt = {dt2}")
ax[1].set_xlabel("Number of steps")
ax[1].set_ylabel("Time [s]")
ax[1].legend()
ax[1].grid()

plt.tight_layout()
plt.show()

print(Ns)
